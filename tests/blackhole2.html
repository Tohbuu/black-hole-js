<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole Simulation with Ray Tracing & Bloom</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: 'Arial', sans-serif;
        }
        
        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        h1 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #4fa3ff;
            text-align: center;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #4fa3ff;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fa3ff;
            cursor: pointer;
        }
        
        .value-display {
            color: #fff;
            font-size: 14px;
            text-align: right;
        }
        
        button {
            padding: 8px 15px;
            background: #2a6bc1;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 10px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #4fa3ff;
        }
        
        .info-panel {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
            font-size: 0.9em;
        }
        
        .info-item {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }
        
        .info-value {
            color: #fff;
            font-weight: bold;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            max-width: 300px;
            backdrop-filter: blur(5px);
            font-size: 0.9em;
        }
        
        .highlight {
            color: #4fa3ff;
            font-weight: bold;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }
        
        .loader {
            border: 5px solid #333;
            border-top: 5px solid #4fa3ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .singularity-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            max-width: 300px;
            backdrop-filter: blur(5px);
            font-size: 0.9em;
        }
        
        .tab-container {
            display: flex;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 8px 12px;
            background: #2a6bc1;
            color: white;
            border: none;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        .tab.active {
            background: #4fa3ff;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .checkbox-group input {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loader"></div>
        <div>Loading Black Hole Simulation...</div>
    </div>
    
    <div id="container"></div>
    
    <div class="singularity-info">
        <h2>Singularity</h2>
        <p>A point of infinite density where all the black hole's mass is concentrated. The laws of physics break down at this point.</p>
    </div>
    
    <div id="ui-container">
        <h1>Black Hole Simulation</h1>
        
        <div class="tab-container">
            <button class="tab active" onclick="switchTab('blackhole-tab')">Black Hole</button>
            <button class="tab" onclick="switchTab('matter-tab')">Matter</button>
            <button class="tab" onclick="switchTab('visual-tab')">Visual</button>
            <button class="tab" onclick="switchTab('bloom-tab')">Bloom</button>
        </div>
        
        <div id="blackhole-tab" class="tab-content active">
            <div class="control-group">
                <label for="massSlider">Black Hole Mass</label>
                <input type="range" id="massSlider" min="5" max="100" value="30">
                <div class="value-display" id="massValue">30 Solar Masses</div>
            </div>
            
            <div class="control-group">
                <label for="spinSlider">Black Hole Spin</label>
                <input type="range" id="spinSlider" min="0" max="100" value="50">
                <div class="value-display" id="spinValue">0.5 c</div>
            </div>
            
            <div class="control-group">
                <label for="accretionSlider">Accretion Disk Brightness</label>
                <input type="range" id="accretionSlider" min="1" max="100" value="70">
                <div class="value-display" id="accretionValue">70%</div>
            </div>
        </div>
        
        <div id="matter-tab" class="tab-content">
            <div class="control-group">
                <label for="matterSlider">Matter Density</label>
                <input type="range" id="matterSlider" min="1" max="100" value="50">
                <div class="value-display" id="matterValue">50%</div>
            </div>
            
            <div class="control-group">
                <label for="velocitySlider">Initial Velocity</label>
                <input type="range" id="velocitySlider" min="1" max="100" value="50">
                <div class="value-display" id="velocityValue">50%</div>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="gravityToggle" checked>
                <label for="gravityToggle">Enable Gravity</label>
            </div>
            
            <div class="control-group">
                <button id="addMatterBtn">Add Matter</button>
                <button id="addRandomBtn">Add Random Matter</button>
            </div>
        </div>
        
        <div id="visual-tab" class="tab-content">
            <div class="control-group">
                <label for="trailSlider">Trail Length</label>
                <input type="range" id="trailSlider" min="1" max="100" value="50">
                <div class="value-display" id="trailValue">50%</div>
            </div>
            
            <div class="control-group">
                <label for="qualitySlider">Render Quality</label>
                <input type="range" id="qualitySlider" min="1" max="100" value="80">
                <div class="value-display" id="qualityValue">80%</div>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="geodesicToggle">
                <label for="geodesicToggle">Enable Geodesic Light Paths</label>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="raytracingToggle" checked>
                <label for="raytracingToggle">Enable Ray Tracing</label>
            </div>
            
            <div class="control-group">
                <button id="resetBtn">Reset Simulation</button>
                <button id="screenshotBtn">Take Screenshot</button>
            </div>
        </div>
        
        <div id="bloom-tab" class="tab-content">
            <div class="control-group">
                <label for="bloomStrength">Bloom Strength</label>
                <input type="range" id="bloomStrength" min="0" max="3" step="0.1" value="1.5">
                <div class="value-display" id="bloomStrengthValue">1.5</div>
            </div>
            
            <div class="control-group">
                <label for="bloomRadius">Bloom Radius</label>
                <input type="range" id="bloomRadius" min="0" max="1" step="0.01" value="0.4">
                <div class="value-display" id="bloomRadiusValue">0.4</div>
            </div>
            
            <div class="control-group">
                <label for="bloomThreshold">Bloom Threshold</label>
                <input type="range" id="bloomThreshold" min="0" max="1" step="0.01" value="0.8">
                <div class="value-display" id="bloomThresholdValue">0.8</div>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="bloomToggle" checked>
                <label for="bloomToggle">Enable Bloom</label>
            </div>
        </div>
        
        <div class="info-panel">
            <div class="info-item">
                <span>Schwarzschild Radius:</span>
                <span class="info-value" id="schwarzschildRadius">17.7 km</span>
            </div>
            <div class="info-item">
                <span>Matter Particles:</span>
                <span class="info-value" id="matterParticles">0</span>
            </div>
            <div class="info-item">
                <span>Matter Captured:</span>
                <span class="info-value" id="matterCaptured">0</span>
            </div>
            <div class="info-item">
                <span>Performance:</span>
                <span class="info-value" id="performance">60 FPS</span>
            </div>
        </div>
    </div>
    
    <div id="instructions">
        <p>• <span class="highlight">Drag</span> to rotate the view</p>
        <p>• <span class="highlight">Scroll</span> to zoom in/out</p>
        <p>• <span class="highlight">Click</span> to add matter at cursor position</p>
        <p>• Use tabs and controls to adjust simulation</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script>
        // UI Tab Functionality
        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabId).classList.add('active');
            event.target.classList.add('active');
        }

        // Show loading screen until everything is ready
        window.addEventListener('load', () => {
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 1000);
        });

        // Constants
        const G = 6.67430e-11;  // Gravitational constant
        const c = 299792458.0;   // Speed of light
        const c2 = c * c;        // c squared
        const SOLAR_MASS = 1.989e30;
        const METERS_PER_UNIT = 1e9; // 1 unit = 1,000,000 km

        // Performance monitoring
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let fps = 60;
        let useGeodesics = false;
        let useRayTracing = true;
        let useBloom = true;

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
        document.getElementById('container').appendChild(renderer.domElement);

        // Post-processing setup
        let composer;
        let bloomPass;
        
        function initPostProcessing() {
            composer = new THREE.EffectComposer(renderer);
            
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // Create bloom pass with proper parameters
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, // strength
                0.4, // radius
                0.8  // threshold
            );
            composer.addPass(bloomPass);
        }

        // Add stars background
        const addStars = () => {
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            
            for (let i = 0; i < 2000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starVertices.push(x, y, z);
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            
            const starMaterial = new THREE.PointsMaterial({ 
                color: 0xffffff, 
                size: 1.2,
                sizeAttenuation: true
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
            return stars;
        };

        const stars = addStars();

        // Camera position
        camera.position.z = 100;
        camera.position.y = 50;

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 30;
        controls.maxDistance = 500;

        // Light source for ray tracing
        const lightPosition = new THREE.Vector3(5, 5, 5);
        const pointLight = new THREE.PointLight(0xffffff, 2, 1000);
        pointLight.position.copy(lightPosition);
        pointLight.decay = 2;
        scene.add(pointLight);

        const lightHelper = new THREE.PointLightHelper(pointLight, 1);
        scene.add(lightHelper);

        // Material class for ray tracing
        class Material {
            constructor(color, specular = 0.5, emission = 0.0) {
                this.color = new THREE.Color(color);
                this.specular = specular;
                this.emission = emission;
            }
        }

        // Object class for ray tracing
        class RayTraceObject {
            constructor(position, radius, material) {
                this.position = position;
                this.radius = radius;
                this.material = material;
                this.mesh = this.createMesh();
                scene.add(this.mesh);
            }
            
            createMesh() {
                const geometry = new THREE.SphereGeometry(this.radius, 16, 16);
                const material = new THREE.MeshBasicMaterial({ 
                    color: this.material.color,
                    transparent: true,
                    opacity: 0.8
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(this.position);
                return mesh;
            }
            
            intersect(rayOrigin, rayDirection) {
                const oc = new THREE.Vector3().subVectors(rayOrigin, this.position);
                const a = rayDirection.dot(rayDirection);
                const b = 2.0 * oc.dot(rayDirection);
                const c = oc.dot(oc) - this.radius * this.radius;
                const discriminant = b * b - 4 * a * c;
                
                if (discriminant < 0) {
                    return -1;
                }
                
                let t = (-b - Math.sqrt(discriminant)) / (2.0 * a);
                if (t < 0) {
                    t = (-b + Math.sqrt(discriminant)) / (2.0 * a);
                }
                
                return t >= 0 ? t : -1;
            }
            
            getNormal(point) {
                return new THREE.Vector3().subVectors(point, this.position).normalize();
            }
        }

        // Black hole class
        class BlackHole {
            constructor(mass, spin = 0.5) {
                this.mass = mass;
                this.spin = spin;
                this.schwarzschildRadius = (2 * G * mass) / c2;
                this.photonSphereRadius = 1.5 * this.schwarzschildRadius;
                
                // Create black hole components
                this.singularity = this.createSingularity();
                this.eventHorizon = this.createEventHorizon();
                this.accretionDisk = this.createAccretionDisk();
                
                // Create ray trace object
                this.rayTraceObject = new RayTraceObject(
                    new THREE.Vector3(0, 0, 0),
                    this.schwarzschildRadius / METERS_PER_UNIT,
                    new Material(0x000000, 0.1, 0.0)
                );
                
                // Add to scene
                scene.add(this.singularity);
                scene.add(this.eventHorizon);
                scene.add(this.accretionDisk);
            }
            
            createSingularity() {
                // Create a pulsing, glowing singularity
                const geometry = new THREE.SphereGeometry(0.8, 32, 32);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.9
                });
                
                const singularity = new THREE.Mesh(geometry, material);
                
                // Add a glowing effect
                const glowGeometry = new THREE.SphereGeometry(1.2, 32, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x6600ff,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                singularity.add(glow);
                
                return singularity;
            }
            
            createEventHorizon() {
                const radius = this.schwarzschildRadius / METERS_PER_UNIT;
                const geometry = new THREE.SphereGeometry(radius, 32, 32);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.8
                });
                const mesh = new THREE.Mesh(geometry, material);
                return mesh;
            }
            
            createAccretionDisk() {
                const innerRadius = this.photonSphereRadius / METERS_PER_UNIT;
                const outerRadius = innerRadius * 5;
                const geometry = new THREE.RingGeometry(innerRadius, outerRadius, 64);
                
                // Create texture for accretion disk with Doppler effect
                const canvas = document.createElement('canvas');
                const width = 256;
                const height = 32;
                canvas.width = width;
                canvas.height = height;
                const context = canvas.getContext('2d');
                
                // Create gradient from blue to red
                const gradient = context.createLinearGradient(0, 0, width, 0);
                gradient.addColorStop(0, '#0000ff');
                gradient.addColorStop(0.3, '#00ffff');
                gradient.addColorStop(0.5, '#ffffff');
                gradient.addColorStop(0.7, '#ffff00');
                gradient.addColorStop(1, '#ff0000');
                
                context.fillStyle = gradient;
                context.fillRect(0, 0, width, height);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({ 
                    map: texture,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.9
                });
                
                const disk = new THREE.Mesh(geometry, material);
                disk.rotation.x = Math.PI / 2;
                return disk;
            }
            
            updateMass(mass) {
                this.mass = mass;
                this.schwarzschildRadius = (2 * G * mass) / c2;
                this.photonSphereRadius = 1.5 * this.schwarzschildRadius;
                
                // Update event horizon
                const newRadius = this.schwarzschildRadius / METERS_PER_UNIT;
                this.eventHorizon.geometry.dispose();
                this.eventHorizon.geometry = new THREE.SphereGeometry(newRadius, 32, 32);
                
                // Update accretion disk
                const innerRadius = this.photonSphereRadius / METERS_PER_UNIT;
                const outerRadius = innerRadius * 5;
                this.accretionDisk.geometry.dispose();
                this.accretionDisk.geometry = new THREE.RingGeometry(innerRadius, outerRadius, 64);
                
                // Update ray trace object
                scene.remove(this.rayTraceObject.mesh);
                this.rayTraceObject = new RayTraceObject(
                    new THREE.Vector3(0, 0, 0),
                    newRadius,
                    new Material(0x000000, 0.1, 0.0)
                );
                
                // Update UI
                document.getElementById('schwarzschildRadius').textContent = 
                    `${(this.schwarzschildRadius / 1000).toFixed(2)} km`;
            }
            
            updateSpin(spin) {
                this.spin = spin;
                this.accretionDisk.rotation.z += 0.01 * this.spin;
            }
            
            animateSingularity(time) {
                const scale = 0.8 + 0.1 * Math.sin(time * 5);
                this.singularity.scale.set(scale, scale, scale);
                
                const glowScale = 1.0 + 0.2 * Math.sin(time * 3);
                if (this.singularity.children[0]) {
                    this.singularity.children[0].scale.set(glowScale, glowScale, glowScale);
                }
            }
            
            getGravitationalAcceleration(position) {
                const rVec = new THREE.Vector3().subVectors(this.singularity.position, position);
                const r = rVec.length();
                
                if (r < 1e-10) {
                    return new THREE.Vector3(0, 0, 0);
                }
                
                const accelerationMagnitude = (G * this.mass) / (r * r * METERS_PER_UNIT * METERS_PER_UNIT);
                return rVec.normalize().multiplyScalar(accelerationMagnitude);
            }
            
            isInsideEventHorizon(position) {
                const distToSingularity = position.distanceTo(this.singularity.position);
                const schwarzschildRadius = this.schwarzschildRadius / METERS_PER_UNIT;
                return distToSingularity < schwarzschildRadius;
            }
        }

        // Matter particle manager
        class MatterManager {
            constructor(maxParticles = 50) {
                this.maxParticles = maxParticles;
                this.particlePool = [];
                this.activeParticles = [];
                this.capturedParticles = 0;
                this.rayTraceObjects = [];
                this.initPool();
            }
            
            initPool() {
                for (let i = 0; i < this.maxParticles; i++) {
                    const particle = {
                        position: new THREE.Vector3(),
                        velocity: new THREE.Vector3(),
                        color: this.getRandomMatterColor(),
                        captured: true,
                        mesh: this.createParticleMesh(),
                        trail: null,
                        trailPoints: []
                    };
                    particle.mesh.visible = false;
                    scene.add(particle.mesh);
                    this.particlePool.push(particle);
                }
            }
            
            getRandomMatterColor() {
                const colors = [0xff3333, 0x33ff33, 0x3333ff, 0xffff33, 0xff33ff, 0x33ffff];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            createParticleMesh() {
                const size = 0.5 + Math.random() * 1.0;
                const geometry = new THREE.SphereGeometry(size, 8, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xff3333,
                    transparent: true,
                    opacity: 0.8
                });
                return new THREE.Mesh(geometry, material);
            }
            
            createParticle(position, velocity) {
                const particle = this.particlePool.find(p => p.captured);
                if (!particle) return null;
                
                particle.position.copy(position);
                particle.velocity.copy(velocity);
                particle.color = this.getRandomMatterColor();
                particle.captured = false;
                particle.trailPoints = [position.clone()];
                particle.mesh.material.color.set(particle.color);
                particle.mesh.position.copy(particle.position);
                particle.mesh.visible = true;
                
                const rayTraceObj = new RayTraceObject(
                    position.clone(),
                    0.5,
                    new Material(particle.color, 0.5, 0.0)
                );
                this.rayTraceObjects.push(rayTraceObj);
                
                if (particle.trail) {
                    scene.remove(particle.trail);
                    particle.trail.geometry.dispose();
                    particle.trail.material.dispose();
                    particle.trail = null;
                }
                
                this.activeParticles.push(particle);
                return particle;
            }
            
            updateParticles(blackHole, dt, gravityEnabled) {
                let capturedCount = 0;
                
                for (let i = this.activeParticles.length - 1; i >= 0; i--) {
                    const particle = this.activeParticles[i];
                    
                    if (particle.captured) {
                        this.activeParticles.splice(i, 1);
                        continue;
                    }
                    
                    if (blackHole.isInsideEventHorizon(particle.position)) {
                        particle.captured = true;
                        particle.mesh.visible = false;
                        capturedCount++;
                        this.capturedParticles++;
                        this.activeParticles.splice(i, 1);
                        
                        const rayTraceObj = this.rayTraceObjects.find(obj => 
                            obj.position.distanceTo(particle.position) < 0.1
                        );
                        if (rayTraceObj) {
                            scene.remove(rayTraceObj.mesh);
                            this.rayTraceObjects = this.rayTraceObjects.filter(obj => obj !== rayTraceObj);
                        }
                        continue;
                    }
                    
                    if (gravityEnabled) {
                        const acceleration = blackHole.getGravitationalAcceleration(particle.position);
                        particle.velocity.add(acceleration.multiplyScalar(dt));
                    }
                    
                    particle.position.add(particle.velocity.clone().multiplyScalar(dt));
                    particle.mesh.position.copy(particle.position);
                    
                    const rayTraceObj = this.rayTraceObjects.find(obj => 
                        obj.position.distanceTo(particle.position) < 1.0
                    );
                    if (rayTraceObj) {
                        rayTraceObj.position.copy(particle.position);
                        rayTraceObj.mesh.position.copy(particle.position);
                    }
                    
                    if (frameCount % 5 === 0) {
                        particle.trailPoints.push(particle.position.clone());
                        const maxTrailLength = 5 + parseInt(document.getElementById('trailSlider').value) / 20;
                        if (particle.trailPoints.length > maxTrailLength) {
                            particle.trailPoints.shift();
                        }
                    }
                    
                    if (frameCount % 10 === 0) {
                        this.drawTrail(particle);
                    }
                }
                
                return capturedCount;
            }
            
            drawTrail(particle) {
                if (particle.trailPoints.length < 2) return;
                
                if (particle.trail) {
                    scene.remove(particle.trail);
                    particle.trail.geometry.dispose();
                    particle.trail.material.dispose();
                }
                
                const points = [];
                for (const point of particle.trailPoints) {
                    points.push(point.clone());
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: particle.color,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 1
                });
                
                particle.trail = new THREE.Line(geometry, material);
                scene.add(particle.trail);
            }
            
            addMatter(blackHole, count = 5, random = false) {
                const velocityFactor = parseInt(document.getElementById('velocitySlider').value) / 50;
                
                for (let i = 0; i < count; i++) {
                    let position, velocity;
                    
                    if (random) {
                        const distance = 50 + Math.random() * 100;
                        const angle = Math.random() * Math.PI * 2;
                        
                        position = new THREE.Vector3(
                            Math.cos(angle) * distance,
                            (Math.random() - 0.5) * 50,
                            Math.sin(angle) * distance
                        );
                        
                        const orbitDirection = new THREE.Vector3(-position.z, 0, position.x).normalize();
                        const randomFactor = 0.7 + Math.random() * 0.6;
                        velocity = orbitDirection.multiplyScalar(15 * randomFactor * velocityFactor);
                    } else {
                        position = new THREE.Vector3(
                            (Math.random() - 0.5) * 20,
                            50,
                            (Math.random() - 0.5) * 20
                        );
                        
                        const direction = new THREE.Vector3().subVectors(
                            blackHole.singularity.position, position
                        ).normalize();
                        
                        velocity = direction.multiplyScalar(10 * velocityFactor);
                    }
                    
                    this.createParticle(position, velocity);
                }
            }
            
            reset() {
                for (const particle of this.activeParticles) {
                    particle.captured = true;
                    particle.mesh.visible = false;
                    
                    if (particle.trail) {
                        scene.remove(particle.trail);
                        particle.trail.geometry.dispose();
                        particle.trail.material.dispose();
                        particle.trail = null;
                    }
                }
                
                for (const obj of this.rayTraceObjects) {
                    scene.remove(obj.mesh);
                }
                this.rayTraceObjects = [];
                
                this.activeParticles = [];
                this.capturedParticles = 0;
            }
            
            getActiveParticleCount() {
                return this.activeParticles.length;
            }
            
            traceRay(rayOrigin, rayDirection, blackHole) {
                let closestT = Infinity;
                let hitObject = null;
                
                const bhT = blackHole.rayTraceObject.intersect(rayOrigin, rayDirection);
                if (bhT > 0 && bhT < closestT) {
                    closestT = bhT;
                    hitObject = blackHole.rayTraceObject;
                }
                
                for (const obj of this.rayTraceObjects) {
                    const t = obj.intersect(rayOrigin, rayDirection);
                    if (t > 0 && t < closestT) {
                        closestT = t;
                        hitObject = obj;
                    }
                }
                
                if (hitObject) {
                    const hitPoint = new THREE.Vector3().copy(rayOrigin).addScaledVector(rayDirection, closestT);
                    const normal = hitObject.getNormal(hitPoint);
                    const lightDir = new THREE.Vector3().subVectors(lightPosition, hitPoint).normalize();
                    
                    const diff = Math.max(normal.dot(lightDir), 0);
                    
                    let inShadow = false;
                    const shadowRayOrigin = new THREE.Vector3().copy(hitPoint).addScaledVector(normal, 0.001);
                    
                    for (const obj of this.rayTraceObjects) {
                        if (obj !== hitObject) {
                            const shadowT = obj.intersect(shadowRayOrigin, lightDir);
                            if (shadowT > 0) {
                                inShadow = true;
                                break;
                            }
                        }
                    }
                    
                    if (!inShadow) {
                        const bhShadowT = blackHole.rayTraceObject.intersect(shadowRayOrigin, lightDir);
                        if (bhShadowT > 0) {
                            inShadow = true;
                        }
                    }
                    
                    const ambient = 0.1;
                    let intensity = ambient;
                    
                    if (!inShadow) {
                        intensity += diff * 0.9;
                    }
                    
                    const color = new THREE.Color().copy(hitObject.material.color);
                    color.multiplyScalar(intensity);
                    
                    return color;
                }
                
                return new THREE.Color(0.0, 0.0, 0.1);
            }
        }

        // Simulation class
        class Simulation {
            constructor() {
                this.blackHole = new BlackHole(30 * SOLAR_MASS, 0.5);
                this.matterManager = new MatterManager(50);
                this.lastTime = performance.now();
                this.gravityEnabled = true;
                
                this.setupEventListeners();
                initPostProcessing();
                this.animate();
            }
            
            setupEventListeners() {
                document.getElementById('massSlider').addEventListener('input', (e) => {
                    const mass = parseInt(e.target.value);
                    this.blackHole.updateMass(mass * SOLAR_MASS);
                    document.getElementById('massValue').textContent = `${mass} Solar Masses`;
                });
                
                document.getElementById('spinSlider').addEventListener('input', (e) => {
                    const spin = parseInt(e.target.value) / 100;
                    this.blackHole.updateSpin(spin);
                    document.getElementById('spinValue').textContent = `${spin.toFixed(2)} c`;
                });
                
                document.getElementById('accretionSlider').addEventListener('input', (e) => {
                    const brightness = parseInt(e.target.value) / 100;
                    this.blackHole.accretionDisk.material.opacity = brightness;
                    document.getElementById('accretionValue').textContent = `${parseInt(e.target.value)}%`;
                });
                
                document.getElementById('matterSlider').addEventListener('input', (e) => {
                    document.getElementById('matterValue').textContent = `${parseInt(e.target.value)}%`;
                });
                
                document.getElementById('velocitySlider').addEventListener('input', (e) => {
                    document.getElementById('velocityValue').textContent = `${parseInt(e.target.value)}%`;
                });
                
                document.getElementById('gravityToggle').addEventListener('change', (e) => {
                    this.gravityEnabled = e.target.checked;
                });
                
                document.getElementById('geodesicToggle').addEventListener('change', (e) => {
                    useGeodesics = e.target.checked;
                });
                
                document.getElementById('raytracingToggle').addEventListener('change', (e) => {
                    useRayTracing = e.target.checked;
                });
                
                document.getElementById('addMatterBtn').addEventListener('click', () => {
                    this.matterManager.addMatter(this.blackHole, 5, false);
                    this.updateUI();
                });
                
                document.getElementById('addRandomBtn').addEventListener('click', () => {
                    this.matterManager.addMatter(this.blackHole, 5, true);
                    this.updateUI();
                });
                
                document.getElementById('trailSlider').addEventListener('input', (e) => {
                    document.getElementById('trailValue').textContent = `${parseInt(e.target.value)}%`;
                });
                
                document.getElementById('qualitySlider').addEventListener('input', (e) => {
                    const quality = parseInt(e.target.value) / 100;
                    renderer.setPixelRatio(Math.min(2 * quality, window.devicePixelRatio));
                    document.getElementById('qualityValue').textContent = `${parseInt(e.target.value)}%`;
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.matterManager.reset();
                    this.updateUI();
                });
                
                document.getElementById('screenshotBtn').addEventListener('click', () => {
                    this.takeScreenshot();
                });
                
                document.getElementById('bloomStrength').addEventListener('input', (e) => {
                    if (bloomPass) {
                        bloomPass.strength = parseFloat(e.target.value);
                        document.getElementById('bloomStrengthValue').textContent = parseFloat(e.target.value).toFixed(1);
                    }
                });
                
                document.getElementById('bloomRadius').addEventListener('input', (e) => {
                    if (bloomPass) {
                        bloomPass.radius = parseFloat(e.target.value);
                        document.getElementById('bloomRadiusValue').textContent = parseFloat(e.target.value).toFixed(2);
                    }
                });
                
                document.getElementById('bloomThreshold').addEventListener('input', (e) => {
                    if (bloomPass) {
                        bloomPass.threshold = parseFloat(e.target.value);
                        document.getElementById('bloomThresholdValue').textContent = parseFloat(e.target.value).toFixed(2);
                    }
                });
                
                document.getElementById('bloomToggle').addEventListener('change', (e) => {
                    useBloom = e.target.checked;
                    if (bloomPass) {
                        bloomPass.enabled = useBloom;
                    }
                });
                
                // Click to add matter
                renderer.domElement.addEventListener('click', (event) => {
                    const mouse = new THREE.Vector2();
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, camera);
                    
                    // Create a plane at the center of the black hole
                    const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                    const intersectionPoint = new THREE.Vector3();
                    raycaster.ray.intersectPlane(plane, intersectionPoint);
                    
                    if (intersectionPoint) {
                        const velocity = new THREE.Vector3(0, 0, 0);
                        this.matterManager.createParticle(intersectionPoint, velocity);
                        this.updateUI();
                    }
                });
                
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    
                    if (composer) {
                        composer.setSize(window.innerWidth, window.innerHeight);
                    }
                });
            }
            
            updateUI() {
                document.getElementById('matterParticles').textContent = this.matterManager.getActiveParticleCount();
                document.getElementById('matterCaptured').textContent = this.matterManager.capturedParticles;
            }
            
            takeScreenshot() {
                renderer.render(scene, camera);
                const dataURL = renderer.domElement.toDataURL('image/png');
                
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = 'blackhole-screenshot.png';
                link.click();
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const currentTime = performance.now();
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                
                // Update FPS counter
                frameCount++;
                if (currentTime - lastFpsUpdate >= 1000) {
                    fps = Math.round(frameCount * 1000 / (currentTime - lastFpsUpdate));
                    document.getElementById('performance').textContent = `${fps} FPS`;
                    frameCount = 0;
                    lastFpsUpdate = currentTime;
                }
                
                // Update black hole animation
                this.blackHole.animateSingularity(currentTime / 1000);
                this.blackHole.accretionDisk.rotation.z += 0.005 * this.blackHole.spin;
                
                // Update matter particles
                const captured = this.matterManager.updateParticles(this.blackHole, deltaTime, this.gravityEnabled);
                if (captured > 0) {
                    this.updateUI();
                }
                
                // Update controls
                controls.update();
                
                // Render the scene
                if (useBloom && composer) {
                    composer.render();
                } else {
                    renderer.render(scene, camera);
                }
            }
        }

        // Initialize the simulation
        let simulation;
        
        window.addEventListener('load', () => {
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                simulation = new Simulation();
            }, 1000);
        });
    </script>
</body>
</html>